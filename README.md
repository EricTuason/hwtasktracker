# hwtasktracker
This project keeps track of time spent on individual tasks. Tasks can be described and given "T-shirt" sizes. 
To use, download TM.java and use Java's single source executable to run. TM.java can be found in src/main/java/tasktracker.
The program generates the file tasktracker.log as storage for this program.
Usage: `java TM.java <command> <data>`.

Commands: start, stop, describe, summary, size, rename, delete. 


## Overview
This project is a task tracker meant to automate the process of timing the time spent on individual tasks. All interaction is meant to be done via a java program that runs on the command line in the format: java TM.java <command> <data>. This uses the single source executable format so the computer the program runs on only needs to have Java 11 installed for this program to run. Every command other than summary is logged in a file named “tasktracker.log” which is used as data storage for the entire program. Summary will print out a list of tasks which can be specified by the user. 
	
## Design Decisions
The summary command will print the user specified list of tasks and possibly print statistics about the tasks. The statistics about the summarized tasks are printed if and only if two or more tasks were specified by the size parameter. If the size or description of a task hasn’t been specified, then those fields are printed and left blank. All reported times are rounded down to the nearest integer second. This makes the summary output look nicer and fractions of a second aren’t important when tracking task time. 

Extensive error checking is performed whenever the program is run. When run, the entire log file must be analyzed to ensure that the current command is compatible with the current state of all the tasks. This is necessary due to the fact that users can write to the log file since it’s a human-readable text file. While this is a desirable feature for this project, it also means that users could introduce nonsensical lines. Thus, a multitude of error checking methods are run, first on the log, then on the command line arguments. 

Each command will check that it received an appropriate number of arguments as a validity. In the case that user input is valid, the command runs as normal, with error checking built into the private helper methods. 
Names cannot be set as S, M, L, or XL since this would cause an unclear use of the summary command since it can accept either a name or a size. Since it is unhelpful to name tasks with the general size terms, it was decided to limit tasking naming in this one scenario. 

Errors will print out a message for what caused the error and will terminate execution of the program immediately. “Error encountered in log file” will also be printed when the error is found within the log file. This is done to ensure that the program doesn’t easily accept tainted data. A multitude of shell scripts have been created to display the expected behavior of this program. They are located within the github for this project under the test cases directory: https://github.com/EricTuason/hwtasktracker/tree/main. 

## Program Architecture and Design
The project is split into three major components: the parser, the command logic, and the data store. The main class, TM, calls on the parser to get commands from the data store. The commands will be executed by TM to create an array of tasks that represent all tasks that are present within the log file. The specified Command subclass will then write to the log or the terminal depending on which Command it is. 

The Task class is the representation of each task created by the user. Its only constructor takes the name as an argument since task identity is contingent on its name. The other fields are: an array of run times, an array of descriptions, the size, and the current start time. Both size and current start time are optional since either could be emptied if the size isn’t specified or the task isn’t currently running, respectively. The total time is stored as an array of each time the task is started and stopped that is summed when the total running time is requested. This means that it would be easy to allow a task to report on each runtime individually if the project specifications were changed. Task has public methods that alter the state of a task. Important to note is that only the stop command has error checking to ensure that a runtime is not negative. All other commands trust that the command is giving them correct data to centralize error checking. 

The Parser class handles general command parsing from both the command line and the log file. When called, it will read its input, and return a concrete instance of the Command class. This allows for runtime polymorphism of the command execution. This also means that implementing a new command only alters Parser in one location, that being the method that generates the command subclass instance. If the data storage method were to be changed, only the getCommandFromLog method would have to change. Alternatively we could extend this Parser class to accept the new data storage method.

The Command abstract class ensures that each command class is cohesive with all the others, and is not coupled with any other classes. The command abstract includes a few protected methods that are likely to be used by each implementation class. The class has four public methods that are used by the TM class that are delegated to the lower classes. The first is a method that makes sure that each command gets the correct arguments from the command line. The second method will perform the command on the list of tasks made from the log file. The third method performs the user-specified command to ensure that it is valid according to the history from the log file. Finally, the fourth command will write to the log file with all the necessary information required to record the full history.  Each subclass of the Command class has its own private methods that serve as helper functions in implementing the four public methods of the Command class. This use of the command pattern makes it easy to implement another command by creating another class which extends the Command class.

The log file is designed to be human readable and is easy to alter, but must be done with caution. The file is created when any task that affects the state of tasks is successfully run without errors. The file is formatted as: <timestamp> <command> <data> on every line. The method to write to the log is located after every other method call in the program. This means that if any error occurs during execution, the command which caused the error will not be printed to the log. This is done to ensure that all data written to the log by the program is as clean as possible. 
